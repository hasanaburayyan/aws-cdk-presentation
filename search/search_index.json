{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AWS Cloud Developer Kit Presentation Info This repo is still a work in progress. Any feedback, questions, or recommendations are greatly appreciated. Intro Building and deploying cloud infrastructure can be a little over whelming, ensuring that the infrastructure can be automated to be reliably redeployed is an additional level of complexity. As Infrastructure as Code (IaC) becomes more popular we are seeing some pretty exciting advancements in this field, one in particular is Cloud Development Kits (CDK). Lets take a some time to talk about IaC and what CDK means in uniting developers with managing their infrastructure. Agenda Infrastructure as Code Terraform CloudFormation CDK Why CDK Imperative vs Declarative The Missing Link (Abstraction) Increased Agility AWS CDK Key Concepts Constructs Stacks Synthesis Aspects Writing Our First Construct Extending the CDK Construct Class Testing our Construct Additional Resources Cloud Development Kit With Elad Ben-Israel part 1 Cloud Development Kit With Elad Ben-Israel part 2 Authored By Name: Hasan Abu-Rayyan Email: hasanaburayyan21@gmail.com Links: | |","title":"AWS Cloud Developer Kit Presentation"},{"location":"#aws-cloud-developer-kit-presentation","text":"Info This repo is still a work in progress. Any feedback, questions, or recommendations are greatly appreciated.","title":"AWS Cloud Developer Kit Presentation"},{"location":"#intro","text":"Building and deploying cloud infrastructure can be a little over whelming, ensuring that the infrastructure can be automated to be reliably redeployed is an additional level of complexity. As Infrastructure as Code (IaC) becomes more popular we are seeing some pretty exciting advancements in this field, one in particular is Cloud Development Kits (CDK). Lets take a some time to talk about IaC and what CDK means in uniting developers with managing their infrastructure.","title":"Intro"},{"location":"#agenda","text":"Infrastructure as Code Terraform CloudFormation CDK Why CDK Imperative vs Declarative The Missing Link (Abstraction) Increased Agility AWS CDK Key Concepts Constructs Stacks Synthesis Aspects Writing Our First Construct Extending the CDK Construct Class Testing our Construct","title":"Agenda"},{"location":"#additional-resources","text":"Cloud Development Kit With Elad Ben-Israel part 1 Cloud Development Kit With Elad Ben-Israel part 2","title":"Additional Resources"},{"location":"#authored-by","text":"Name: Hasan Abu-Rayyan Email: hasanaburayyan21@gmail.com Links: | |","title":"Authored By"},{"location":"about/about-me/","text":"About The Author Introduction My name is Hasan, I am overtly passionate about computer science, so please excuse the excitement and occasional ramblings. By day I work on the AWS application migration efforts of the North Star 21 initiative, by night I help teach students at Franklin University Object Oriented Programming and Data Structures. In my free time I enjoy to miserably fail at trying to convince my wife and 3 children they love computer science as much as I do. Some other hobbies include; archery, yoyos, and watching movies that are soo terrible they are wonderful! Favorite Quote: \"Computer science is no more about computers than astronomy is about telescopes\" - Edsger Dijkstra","title":"About The Author"},{"location":"about/about-me/#about-the-author","text":"","title":"About The Author"},{"location":"about/about-me/#introduction","text":"My name is Hasan, I am overtly passionate about computer science, so please excuse the excitement and occasional ramblings. By day I work on the AWS application migration efforts of the North Star 21 initiative, by night I help teach students at Franklin University Object Oriented Programming and Data Structures. In my free time I enjoy to miserably fail at trying to convince my wife and 3 children they love computer science as much as I do. Some other hobbies include; archery, yoyos, and watching movies that are soo terrible they are wonderful! Favorite Quote: \"Computer science is no more about computers than astronomy is about telescopes\" - Edsger Dijkstra","title":"Introduction"},{"location":"building-reusable-code/building-reusable-code/","text":"Building Reusable Code JSii allows code in any language to naturally interact with JavaScript classes. It is the technology that enables the AWS Cloud Development Kit to deliver polyglot libraries from a single codebase! A class library written in TypeScript can be used in projects authored in TypeScript or Javascript (as usual), but also in Python, Java, C# (and other languages from the .NET family), ... For More On JSii Projen Define and maintain complex project configuration through code. projen synthesizes project configuration files such as package.json, tsconfig.json, .gitignore, GitHub Workflows, eslint, jest, etc from a well-typed definition written in JavaScript. As opposed to existing templating/scaffolding tools, projen is not a one-off generator. Synthesized files should never be manually edited (in fact, projen enforces that). To modify your project setup, users interact with rich strongly-typed class and execute projen to update their project configuration files. A CDK for project creation. Gives us well defined APIs and Object Oriented Principles when creating and maintaining new projects. Can Keep Project JSii Compliant!! For More On Projen Projen RC File Examples","title":"Building Reusable Code"},{"location":"building-reusable-code/building-reusable-code/#building-reusable-code","text":"","title":"Building Reusable Code"},{"location":"building-reusable-code/building-reusable-code/#jsii","text":"allows code in any language to naturally interact with JavaScript classes. It is the technology that enables the AWS Cloud Development Kit to deliver polyglot libraries from a single codebase! A class library written in TypeScript can be used in projects authored in TypeScript or Javascript (as usual), but also in Python, Java, C# (and other languages from the .NET family), ... For More On JSii","title":"JSii"},{"location":"building-reusable-code/building-reusable-code/#projen","text":"Define and maintain complex project configuration through code. projen synthesizes project configuration files such as package.json, tsconfig.json, .gitignore, GitHub Workflows, eslint, jest, etc from a well-typed definition written in JavaScript. As opposed to existing templating/scaffolding tools, projen is not a one-off generator. Synthesized files should never be manually edited (in fact, projen enforces that). To modify your project setup, users interact with rich strongly-typed class and execute projen to update their project configuration files. A CDK for project creation. Gives us well defined APIs and Object Oriented Principles when creating and maintaining new projects. Can Keep Project JSii Compliant!! For More On Projen","title":"Projen"},{"location":"building-reusable-code/building-reusable-code/#projen-rc-file-examples","text":"","title":"Projen RC File Examples"},{"location":"cdk-key-concepts/aspects/","text":"","title":"Aspects"},{"location":"cdk-key-concepts/cdk-key-concepts/","text":"CDK Core Concepts The real potential behind CDK is unlocked when we have a solid understanding of some key concepts in CDK. Here we will review some of those concepts in order to comprehend how we can make use of constructs, and the CDK construct tree. Constructs Constructs are the basic building blocks of a CDK application. AWS describes constructs as representing a \"cloud component\" and encapsulates everything CloudFormation needs to create the component. Important Note: Constructs can represent a single resource OR they can represent high level components consisting of multiple resources that span across multiple accounts. More Construct Details Here Stacks Stacks are the unit of deployment for CDK. Any resource that is deployed with CDK will be defined within the scope of a stack. CDK stacks are implemented using CloudFormation Stacks, so they share the same limitations. There are currently no limits on the number of stacks we can define within our CDK app. Stacks can be managed through the use of constructs as well. Construct Tree CDK Constructs are managed via the use of the Construct Tree. The construct tree enables us to define constructs inside of other constructs. The tree will maintain the scope for each construct. This data structure allows us to easily manage nested stacks, enforce stack deployment order, and even do some cool validation at synthesis time using existing or custom Aspects. Aspects Aspects allow us to apply some operation to all constructs within a scope. This is enabled by the Construct tree, since the tree maintains scope for all constructs, stacks, and resources. These are AWS CDK's take on the visitor pattern. Synthesis CDK Synthesis is the process of converting our code into usable CloudFormation templates. During Synthesis the Construct tree is traversed and assets will be marked for deployment into AWS upon the next CDK deployment.","title":"CDK Core Concepts"},{"location":"cdk-key-concepts/cdk-key-concepts/#cdk-core-concepts","text":"The real potential behind CDK is unlocked when we have a solid understanding of some key concepts in CDK. Here we will review some of those concepts in order to comprehend how we can make use of constructs, and the CDK construct tree.","title":"CDK Core Concepts"},{"location":"cdk-key-concepts/cdk-key-concepts/#constructs","text":"Constructs are the basic building blocks of a CDK application. AWS describes constructs as representing a \"cloud component\" and encapsulates everything CloudFormation needs to create the component. Important Note: Constructs can represent a single resource OR they can represent high level components consisting of multiple resources that span across multiple accounts. More Construct Details Here","title":"Constructs"},{"location":"cdk-key-concepts/cdk-key-concepts/#stacks","text":"Stacks are the unit of deployment for CDK. Any resource that is deployed with CDK will be defined within the scope of a stack. CDK stacks are implemented using CloudFormation Stacks, so they share the same limitations. There are currently no limits on the number of stacks we can define within our CDK app. Stacks can be managed through the use of constructs as well.","title":"Stacks"},{"location":"cdk-key-concepts/cdk-key-concepts/#construct-tree","text":"CDK Constructs are managed via the use of the Construct Tree. The construct tree enables us to define constructs inside of other constructs. The tree will maintain the scope for each construct. This data structure allows us to easily manage nested stacks, enforce stack deployment order, and even do some cool validation at synthesis time using existing or custom Aspects.","title":"Construct Tree"},{"location":"cdk-key-concepts/cdk-key-concepts/#aspects","text":"Aspects allow us to apply some operation to all constructs within a scope. This is enabled by the Construct tree, since the tree maintains scope for all constructs, stacks, and resources. These are AWS CDK's take on the visitor pattern.","title":"Aspects"},{"location":"cdk-key-concepts/cdk-key-concepts/#synthesis","text":"CDK Synthesis is the process of converting our code into usable CloudFormation templates. During Synthesis the Construct tree is traversed and assets will be marked for deployment into AWS upon the next CDK deployment.","title":"Synthesis"},{"location":"cdk-key-concepts/construct-tree/","text":"","title":"Construct tree"},{"location":"cdk-key-concepts/constructs/","text":"Construct Levels: The construct library includes 3 level of constructs available to us. L1 Cfn Resources these constructs are very low level. They represent CloudFormation resources, and require you to explicitly configure all resource properties which requires a deep understanding of the CloudFormation resource model. L2 Intent based Resources L2 constructs allow us to represent AWS resources in a higher-level context, where we focus on intent-based definitions. This is done via CDK's implementation of default boilerplate, and common best practice logic. L3 Patterns The highest level of constructs are known as patterns. These are common tasks defined by AWS that involve multiple kinds resources. Examples Level 1 Construct CfnVPC Here I create a level 1 vpc construct. This construct has 1 required property cidrBlock which you can see matches exactly with the required properties in CloudFormation for VPC creation CloudFormation Definition . new ec2 . CfnVPC ( this , 'level1-vpc' , { cidrBlock : \"10.0.0.0/16\" }) If we take a look at the construct tree produced by this we can see that only 1 resource is being created during synthesis of our CDK construct - tree `-- my-new-stack ` -- level1 - vpc Level 2 Construct VPC Now from the same package ec2 I will make a VPC using the level 2 construct. Note that this has 0 required properties new ec2 . Vpc ( this , 'level2-vpc' , { }) Unlike the level 1 construct we can see that this construct tree will create and manage MANY more AWS resources. construct - tree `-- my-new-stack ` -- level2 - vpc |-- Resource |-- PublicSubnet1 | |-- Subnet | |-- Acl | |-- RouteTable | |-- RouteTableAssociation | |-- DefaultRoute | |-- EIP | `-- NATGateway |-- PublicSubnet2 | |-- Subnet | |-- Acl | |-- RouteTable | |-- RouteTableAssociation | |-- DefaultRoute | |-- EIP | ` -- NATGateway |-- PublicSubnet3 | |-- Subnet | |-- Acl | |-- RouteTable | |-- RouteTableAssociation | |-- DefaultRoute | |-- EIP | `-- NATGateway |-- PrivateSubnet1 | |-- Subnet | |-- Acl | |-- RouteTable | |-- RouteTableAssociation | ` -- DefaultRoute |-- PrivateSubnet2 | |-- Subnet | |-- Acl | |-- RouteTable | |-- RouteTableAssociation | `-- DefaultRoute |-- PrivateSubnet3 | |-- Subnet | |-- Acl | |-- RouteTable | |-- RouteTableAssociation | ` -- DefaultRoute |-- IGW `-- VPCGW Level 3 Construct (Pattern) Here I am going to use a level 3 construct called ecs pattern ApplicationLoadbalancedFargateService new ecsPatterns . ApplicationLoadBalancedFargateService ( this , 'level3-ecs-pattern' , { taskImageOptions : { image : ecs.ContainerImage.fromEcrRepository ( ecr . Repository . fromRepositoryName ( this , 'my-nginx-repo' , 'nginx' ) ) } }) Now when we take a look at our construct tree we can see that many resources are being created here just like with the previous level 2 examples. The big difference here is that this level 3 construct is creating resources from other libraries other than just the ecs package. We can see below the following: ecs (cluster, task, services) ec2 (load balancers, security groups, vpc, etc...) Cloudwatch (log groups) construct - tree `-- my-new-stack |-- my-nginx-repo |-- level3-ecs-pattern | |-- LB | | |-- Resource | | |-- SecurityGroup | | | |-- Resource | | | ` -- to mynewstacklevel3ecspatternServiceSecurityGroup4E669D7C : 80 | | `-- PublicListener | | |-- Resource | | ` -- ECSGroup | | `-- Resource | |-- LoadBalancerDNS | |-- ServiceURL | |-- TaskDef | | |-- TaskRole | | | ` -- Resource | | |-- Resource | | |-- web | | | `-- LogGroup | | | ` -- Resource | | `-- ExecutionRole | | |-- Resource | | ` -- DefaultPolicy | | `-- Resource | ` -- Service | |-- Service | `-- SecurityGroup | |-- Resource | |-- from mynewstacklevel3ecspatternLBSecurityGroup2A462752:80 ` -- EcsDefaultClusterMnL3mNNYN |-- Resource `-- Vpc |-- Resource |-- PublicSubnet1 | |-- Subnet | |-- Acl | |-- RouteTable | |-- RouteTableAssociation | |-- DefaultRoute | |-- EIP | ` -- NATGateway |-- PublicSubnet2 | |-- Subnet | |-- Acl | |-- RouteTable | |-- RouteTableAssociation | |-- DefaultRoute | |-- EIP | `-- NATGateway |-- PrivateSubnet1 | |-- Subnet | |-- Acl | |-- RouteTable | |-- RouteTableAssociation | ` -- DefaultRoute |-- PrivateSubnet2 | |-- Subnet | |-- Acl | |-- RouteTable | |-- RouteTableAssociation | `-- DefaultRoute |-- IGW ` -- VPCGW","title":"Constructs"},{"location":"cdk-key-concepts/constructs/#construct-levels","text":"The construct library includes 3 level of constructs available to us. L1 Cfn Resources these constructs are very low level. They represent CloudFormation resources, and require you to explicitly configure all resource properties which requires a deep understanding of the CloudFormation resource model. L2 Intent based Resources L2 constructs allow us to represent AWS resources in a higher-level context, where we focus on intent-based definitions. This is done via CDK's implementation of default boilerplate, and common best practice logic. L3 Patterns The highest level of constructs are known as patterns. These are common tasks defined by AWS that involve multiple kinds resources.","title":"Construct Levels:"},{"location":"cdk-key-concepts/constructs/#examples","text":"","title":"Examples"},{"location":"cdk-key-concepts/constructs/#level-1-construct-cfnvpc","text":"Here I create a level 1 vpc construct. This construct has 1 required property cidrBlock which you can see matches exactly with the required properties in CloudFormation for VPC creation CloudFormation Definition . new ec2 . CfnVPC ( this , 'level1-vpc' , { cidrBlock : \"10.0.0.0/16\" }) If we take a look at the construct tree produced by this we can see that only 1 resource is being created during synthesis of our CDK construct - tree `-- my-new-stack ` -- level1 - vpc","title":"Level 1 Construct CfnVPC"},{"location":"cdk-key-concepts/constructs/#level-2-construct-vpc","text":"Now from the same package ec2 I will make a VPC using the level 2 construct. Note that this has 0 required properties new ec2 . Vpc ( this , 'level2-vpc' , { }) Unlike the level 1 construct we can see that this construct tree will create and manage MANY more AWS resources. construct - tree `-- my-new-stack ` -- level2 - vpc |-- Resource |-- PublicSubnet1 | |-- Subnet | |-- Acl | |-- RouteTable | |-- RouteTableAssociation | |-- DefaultRoute | |-- EIP | `-- NATGateway |-- PublicSubnet2 | |-- Subnet | |-- Acl | |-- RouteTable | |-- RouteTableAssociation | |-- DefaultRoute | |-- EIP | ` -- NATGateway |-- PublicSubnet3 | |-- Subnet | |-- Acl | |-- RouteTable | |-- RouteTableAssociation | |-- DefaultRoute | |-- EIP | `-- NATGateway |-- PrivateSubnet1 | |-- Subnet | |-- Acl | |-- RouteTable | |-- RouteTableAssociation | ` -- DefaultRoute |-- PrivateSubnet2 | |-- Subnet | |-- Acl | |-- RouteTable | |-- RouteTableAssociation | `-- DefaultRoute |-- PrivateSubnet3 | |-- Subnet | |-- Acl | |-- RouteTable | |-- RouteTableAssociation | ` -- DefaultRoute |-- IGW `-- VPCGW","title":"Level 2 Construct VPC"},{"location":"cdk-key-concepts/constructs/#level-3-construct-pattern","text":"Here I am going to use a level 3 construct called ecs pattern ApplicationLoadbalancedFargateService new ecsPatterns . ApplicationLoadBalancedFargateService ( this , 'level3-ecs-pattern' , { taskImageOptions : { image : ecs.ContainerImage.fromEcrRepository ( ecr . Repository . fromRepositoryName ( this , 'my-nginx-repo' , 'nginx' ) ) } }) Now when we take a look at our construct tree we can see that many resources are being created here just like with the previous level 2 examples. The big difference here is that this level 3 construct is creating resources from other libraries other than just the ecs package. We can see below the following: ecs (cluster, task, services) ec2 (load balancers, security groups, vpc, etc...) Cloudwatch (log groups) construct - tree `-- my-new-stack |-- my-nginx-repo |-- level3-ecs-pattern | |-- LB | | |-- Resource | | |-- SecurityGroup | | | |-- Resource | | | ` -- to mynewstacklevel3ecspatternServiceSecurityGroup4E669D7C : 80 | | `-- PublicListener | | |-- Resource | | ` -- ECSGroup | | `-- Resource | |-- LoadBalancerDNS | |-- ServiceURL | |-- TaskDef | | |-- TaskRole | | | ` -- Resource | | |-- Resource | | |-- web | | | `-- LogGroup | | | ` -- Resource | | `-- ExecutionRole | | |-- Resource | | ` -- DefaultPolicy | | `-- Resource | ` -- Service | |-- Service | `-- SecurityGroup | |-- Resource | |-- from mynewstacklevel3ecspatternLBSecurityGroup2A462752:80 ` -- EcsDefaultClusterMnL3mNNYN |-- Resource `-- Vpc |-- Resource |-- PublicSubnet1 | |-- Subnet | |-- Acl | |-- RouteTable | |-- RouteTableAssociation | |-- DefaultRoute | |-- EIP | ` -- NATGateway |-- PublicSubnet2 | |-- Subnet | |-- Acl | |-- RouteTable | |-- RouteTableAssociation | |-- DefaultRoute | |-- EIP | `-- NATGateway |-- PrivateSubnet1 | |-- Subnet | |-- Acl | |-- RouteTable | |-- RouteTableAssociation | ` -- DefaultRoute |-- PrivateSubnet2 | |-- Subnet | |-- Acl | |-- RouteTable | |-- RouteTableAssociation | `-- DefaultRoute |-- IGW ` -- VPCGW","title":"Level 3 Construct (Pattern)"},{"location":"cdk-key-concepts/stacks/","text":"","title":"Stacks"},{"location":"cdk-key-concepts/synthesis/","text":"Synthesis Hey Im synthesizing here!","title":"Synthesis"},{"location":"cdk-key-concepts/synthesis/#synthesis","text":"Hey Im synthesizing here!","title":"Synthesis"},{"location":"creating-a-construct/testing-cdk/","text":"Testing CDK Sample Stack With Tags import * as cdk from \"@aws-cdk/core\" ; import { RemovalPolicy } from \"@aws-cdk/core\" ; import * as s3 from \"@aws-cdk/aws-s3\" ; export class SampleStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); let myBucket = new s3 . Bucket ( this , 'super-cool-bucket' , { bucketName : \"my-super-cool-bucket\" , removalPolicy : RemovalPolicy.DESTROY , publicReadAccess : true }); cdk . Tags . of ( this ). add ( \"created-by\" , \"me\" ) cdk . Tags . of ( this ). add ( \"contact-fax\" , \"614-555-1122\" ) } } Testing The Stack import * as cdk from '@aws-cdk/core' ; import '@aws-cdk/assert/jest' ; import { expect as expectCDK , haveResource , haveResourceLike } from '@aws-cdk/assert' ; import { SampleStack } from \"../lib/sample-stack\" ; test ( 'Check Tags' , () => { // GIVEN const app = new cdk . App (); // WHEN const stack : cdk.Stack = new SampleStack ( app , 'my-test-stack' ) // THEN expectCDK ( stack ). to ( haveResourceLike ( \"AWS::S3::Bucket\" , { \"Tags\" : [ { \"Key\" : \"created-by\" }, { \"Key\" : \"contact-fax\" } ] })) });","title":"Testing CDK"},{"location":"creating-a-construct/testing-cdk/#testing-cdk","text":"","title":"Testing CDK"},{"location":"creating-a-construct/testing-cdk/#sample-stack-with-tags","text":"import * as cdk from \"@aws-cdk/core\" ; import { RemovalPolicy } from \"@aws-cdk/core\" ; import * as s3 from \"@aws-cdk/aws-s3\" ; export class SampleStack extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); let myBucket = new s3 . Bucket ( this , 'super-cool-bucket' , { bucketName : \"my-super-cool-bucket\" , removalPolicy : RemovalPolicy.DESTROY , publicReadAccess : true }); cdk . Tags . of ( this ). add ( \"created-by\" , \"me\" ) cdk . Tags . of ( this ). add ( \"contact-fax\" , \"614-555-1122\" ) } }","title":"Sample Stack With Tags"},{"location":"creating-a-construct/testing-cdk/#testing-the-stack","text":"import * as cdk from '@aws-cdk/core' ; import '@aws-cdk/assert/jest' ; import { expect as expectCDK , haveResource , haveResourceLike } from '@aws-cdk/assert' ; import { SampleStack } from \"../lib/sample-stack\" ; test ( 'Check Tags' , () => { // GIVEN const app = new cdk . App (); // WHEN const stack : cdk.Stack = new SampleStack ( app , 'my-test-stack' ) // THEN expectCDK ( stack ). to ( haveResourceLike ( \"AWS::S3::Bucket\" , { \"Tags\" : [ { \"Key\" : \"created-by\" }, { \"Key\" : \"contact-fax\" } ] })) });","title":"Testing The Stack"},{"location":"infrastructure-as-code/iac/","text":"Infrastructure As Code Infrastructure As Code (IaC) gives us a way to manage the provisioning of our infrastructure resources as code. Making our deployment and configuration process of physical and virtual equipment faster and reliably repeatable. Typically there are two types of IaC, declarative (functional) and imperative (procedural). We will discuss the differences in more depth shortly. Basic Pub Sub Model CloudFormation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 Resources : myTopic : Type : 'AWS::SNS::Topic' Properties : TopicName : my-cool-topic myQueue : Type : 'AWS::SQS::Queue' Properties : QueueName : my-cool-queue UpdateReplacePolicy : Delete DeletionPolicy : Delete mySnsSubscription : Type : 'AWS::SNS::Subscription' Properties : Protocol : sqs TopicArn : !Ref myTopic Endpoint : !GetAtt - myQueue - Arn mylambdaServiceRole : Type : 'AWS::IAM::Role' Properties : AssumeRolePolicyDocument : Statement : - Action : 'sts:AssumeRole' Effect : Allow Principal : Service : lambda.amazonaws.com Version : 2012-10-17 ManagedPolicyArns : - !Join - '' - - 'arn:' - !Ref 'AWS::Partition' - ':iam::aws:policy/service-role/AWSLambdaBasicExecutionRole' mylambdaServiceRoleDefaultPolicy : Type : 'AWS::IAM::Policy' Properties : PolicyDocument : Statement : - Action : - 'sqs:ReceiveMessage' - 'sqs:ChangeMessageVisibility' - 'sqs:GetQueueUrl' - 'sqs:DeleteMessage' - 'sqs:GetQueueAttributes' Effect : Allow Resource : !GetAtt - myQueue - Arn Version : 2012-10-17 PolicyName : mylambdaServiceRoleDefaultPolicy Roles : - !Ref mylambdaServiceRole mylambda : Type : 'AWS::Lambda::Function' Properties : Code : S3Bucket : !Ref WHATEVER_BUCKET_YOU_UPLOADED_LAMBDA_TO S3Key : !Ref KEY_TO_REFERENCE_LAMBDA Role : !GetAtt - mylambdaServiceRole - Arn Environment : Variables : QUEUE_ARN : !GetAtt - myQueue - Arn QUEUE_NAME : !GetAtt - myQueue - QueueName Handler : empty-queue.handler Runtime : python3.8 DependsOn : - mylambdaServiceRoleDefaultPolicy - mylambdaServiceRole mylambdaSqsEvent : Type : 'AWS::Lambda::EventSourceMapping' Properties : FunctionName : !Ref mylambda EventSourceArn : !GetAtt - myQueue - Arn Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 terraf orm { required_providers { aws = { source = \"hashicorp/aws\" versio n = \"3.58.0\" } } } provider \"aws\" { regio n = \"us-east-2\" } resource \"aws_sns_topic\" \"user_updates\" { na me = \"user-updates-topic\" } resource \"aws_sqs_queue\" \"terraform_queue\" { na me = \"terraform-example-queue\" } resource \"aws_sns_topic_subscription\" \"user_updates_sqs_target\" { t opic_ar n = \"arn:aws:sns:us-west-2:432981146916:user-updates-topic\" pro t ocol = \"sqs\" e n dpoi nt = \"arn:aws:sqs:us-west-2:432981146916:terraform-queue-too\" } resource \"aws_iam_role\" \"iam_for_lambda\" { na me = \"iam_for_lambda\" assume_role_policy = <<EOF { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Action\" : \"sts:AssumeRole\" , \"Principal\" : { \"Service\" : \"lambda.amazonaws.com\" }, \"Effect\" : \"Allow\" , \"Sid\" : \"\" } ] } EOF } resource \"aws_lambda_function\" \"test_lambda\" { f ile na me = \"empty-queue.py\" fun c t io n _ na me = \"handler\" role = aws_iam_role.iam_ f or_lambda.ar n ha n dler = \"empty-queue.handler\" source_code_hash = f ilebase 64 sha 256 ( \"lambda_function_payload.zip\" ) ru nt ime = \"nodejs12.x\" e n viro n me nt { variables = { f oo = \"bar\" } } } CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import * as path from 'path' ; import * as lambda from '@aws-cdk/aws-lambda' ; import * as lambdaEventSources from '@aws-cdk/aws-lambda-event-sources' ; import * as sns from '@aws-cdk/aws-sns' ; import * as sqs from '@aws-cdk/aws-sqs' ; import * as cdk from '@aws-cdk/core' ; export class PubSubModel extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); let myTopic = new sns . Topic ( this , 'my-topic' , { topicName : 'my-cool-topic' , }); let myQueue = new sqs . Queue ( this , 'my-sqs-queue' , { queueName : 'my-cool-queue' , }); new sns . Subscription ( this , 'my-sns-subscription' , { topic : myTopic , protocol : sns.SubscriptionProtocol.SQS , endpoint : myQueue.queueArn , }); let myLambda = new lambda . Function ( this , 'my-lambda' , { runtime : lambda.Runtime.PYTHON_3_8 , handler : 'empty-queue.handler' , code : lambda.Code.fromAsset ( path . join ( __dirname , './lambda_scripts' ), { exclude : [ '**' , '!empty-queue.py' ], }, ), environment : { QUEUE_ARN : myQueue.queueArn , QUEUE_NAME : myQueue.queueName , }, }); myQueue . grantConsumeMessages ( myLambda ); myLambda . addEventSource ( new lambdaEventSources . SqsEventSource ( myQueue )); } } Lambda Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import json import logging import os import boto3 from __future__ import print_function SUCCESS = \"SUCCESS\" FAILED = \"FAILED\" QUEUE_ARN = os . getenv ( 'QUEUE_ARN' ) QUEUE_NAME = os . getenv ( 'QUEUE_NAME' ) LOGGER = logging . getLogger ( __name__ ) LOGGER . setLevel ( logging . DEBUG ) sqs = boto3 . resource ( 'sqs' ) def handler ( event , context ): LOGGER . info ( \"Recieved event: \" + json . dumps ( event , indent = 2 )) for record in event [ 'Records' ]: print ( \"test\" ) payload = record [ \"body\" ] print ( str ( payload ))","title":"Infrastructure As Code"},{"location":"infrastructure-as-code/iac/#infrastructure-as-code","text":"Infrastructure As Code (IaC) gives us a way to manage the provisioning of our infrastructure resources as code. Making our deployment and configuration process of physical and virtual equipment faster and reliably repeatable. Typically there are two types of IaC, declarative (functional) and imperative (procedural). We will discuss the differences in more depth shortly.","title":"Infrastructure As Code"},{"location":"infrastructure-as-code/iac/#basic-pub-sub-model","text":"CloudFormation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 Resources : myTopic : Type : 'AWS::SNS::Topic' Properties : TopicName : my-cool-topic myQueue : Type : 'AWS::SQS::Queue' Properties : QueueName : my-cool-queue UpdateReplacePolicy : Delete DeletionPolicy : Delete mySnsSubscription : Type : 'AWS::SNS::Subscription' Properties : Protocol : sqs TopicArn : !Ref myTopic Endpoint : !GetAtt - myQueue - Arn mylambdaServiceRole : Type : 'AWS::IAM::Role' Properties : AssumeRolePolicyDocument : Statement : - Action : 'sts:AssumeRole' Effect : Allow Principal : Service : lambda.amazonaws.com Version : 2012-10-17 ManagedPolicyArns : - !Join - '' - - 'arn:' - !Ref 'AWS::Partition' - ':iam::aws:policy/service-role/AWSLambdaBasicExecutionRole' mylambdaServiceRoleDefaultPolicy : Type : 'AWS::IAM::Policy' Properties : PolicyDocument : Statement : - Action : - 'sqs:ReceiveMessage' - 'sqs:ChangeMessageVisibility' - 'sqs:GetQueueUrl' - 'sqs:DeleteMessage' - 'sqs:GetQueueAttributes' Effect : Allow Resource : !GetAtt - myQueue - Arn Version : 2012-10-17 PolicyName : mylambdaServiceRoleDefaultPolicy Roles : - !Ref mylambdaServiceRole mylambda : Type : 'AWS::Lambda::Function' Properties : Code : S3Bucket : !Ref WHATEVER_BUCKET_YOU_UPLOADED_LAMBDA_TO S3Key : !Ref KEY_TO_REFERENCE_LAMBDA Role : !GetAtt - mylambdaServiceRole - Arn Environment : Variables : QUEUE_ARN : !GetAtt - myQueue - Arn QUEUE_NAME : !GetAtt - myQueue - QueueName Handler : empty-queue.handler Runtime : python3.8 DependsOn : - mylambdaServiceRoleDefaultPolicy - mylambdaServiceRole mylambdaSqsEvent : Type : 'AWS::Lambda::EventSourceMapping' Properties : FunctionName : !Ref mylambda EventSourceArn : !GetAtt - myQueue - Arn Terraform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 terraf orm { required_providers { aws = { source = \"hashicorp/aws\" versio n = \"3.58.0\" } } } provider \"aws\" { regio n = \"us-east-2\" } resource \"aws_sns_topic\" \"user_updates\" { na me = \"user-updates-topic\" } resource \"aws_sqs_queue\" \"terraform_queue\" { na me = \"terraform-example-queue\" } resource \"aws_sns_topic_subscription\" \"user_updates_sqs_target\" { t opic_ar n = \"arn:aws:sns:us-west-2:432981146916:user-updates-topic\" pro t ocol = \"sqs\" e n dpoi nt = \"arn:aws:sqs:us-west-2:432981146916:terraform-queue-too\" } resource \"aws_iam_role\" \"iam_for_lambda\" { na me = \"iam_for_lambda\" assume_role_policy = <<EOF { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Action\" : \"sts:AssumeRole\" , \"Principal\" : { \"Service\" : \"lambda.amazonaws.com\" }, \"Effect\" : \"Allow\" , \"Sid\" : \"\" } ] } EOF } resource \"aws_lambda_function\" \"test_lambda\" { f ile na me = \"empty-queue.py\" fun c t io n _ na me = \"handler\" role = aws_iam_role.iam_ f or_lambda.ar n ha n dler = \"empty-queue.handler\" source_code_hash = f ilebase 64 sha 256 ( \"lambda_function_payload.zip\" ) ru nt ime = \"nodejs12.x\" e n viro n me nt { variables = { f oo = \"bar\" } } } CDK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import * as path from 'path' ; import * as lambda from '@aws-cdk/aws-lambda' ; import * as lambdaEventSources from '@aws-cdk/aws-lambda-event-sources' ; import * as sns from '@aws-cdk/aws-sns' ; import * as sqs from '@aws-cdk/aws-sqs' ; import * as cdk from '@aws-cdk/core' ; export class PubSubModel extends cdk . Stack { constructor ( scope : cdk.Construct , id : string , props? : cdk.StackProps ) { super ( scope , id , props ); let myTopic = new sns . Topic ( this , 'my-topic' , { topicName : 'my-cool-topic' , }); let myQueue = new sqs . Queue ( this , 'my-sqs-queue' , { queueName : 'my-cool-queue' , }); new sns . Subscription ( this , 'my-sns-subscription' , { topic : myTopic , protocol : sns.SubscriptionProtocol.SQS , endpoint : myQueue.queueArn , }); let myLambda = new lambda . Function ( this , 'my-lambda' , { runtime : lambda.Runtime.PYTHON_3_8 , handler : 'empty-queue.handler' , code : lambda.Code.fromAsset ( path . join ( __dirname , './lambda_scripts' ), { exclude : [ '**' , '!empty-queue.py' ], }, ), environment : { QUEUE_ARN : myQueue.queueArn , QUEUE_NAME : myQueue.queueName , }, }); myQueue . grantConsumeMessages ( myLambda ); myLambda . addEventSource ( new lambdaEventSources . SqsEventSource ( myQueue )); } } Lambda Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import json import logging import os import boto3 from __future__ import print_function SUCCESS = \"SUCCESS\" FAILED = \"FAILED\" QUEUE_ARN = os . getenv ( 'QUEUE_ARN' ) QUEUE_NAME = os . getenv ( 'QUEUE_NAME' ) LOGGER = logging . getLogger ( __name__ ) LOGGER . setLevel ( logging . DEBUG ) sqs = boto3 . resource ( 'sqs' ) def handler ( event , context ): LOGGER . info ( \"Recieved event: \" + json . dumps ( event , indent = 2 )) for record in event [ 'Records' ]: print ( \"test\" ) payload = record [ \"body\" ] print ( str ( payload ))","title":"Basic Pub Sub Model"},{"location":"infrastructure-as-code/what-is-cdk/","text":"What is AWS CDK? AWS Cloud Development Kit (CDK) is an opensource software development framework used to define our Infrastructure as Code (IaC). Using CDK allows us to use familiar programming languages to provision our AWS Resources. At its core CDK makes use of AWS CloudFormation in order to deploy our AWS resources. This makes having some level of CloudFormation understanding very useful as you continue to create your CDK application templates. Important Important Note: Keep in mind, though CDK uses CloudFormation we are NOT writing CloudFormation templates in Typescript or Python. We are writing CDK code that happens to use CloudFormation for deployment. CDK vs. Pure CloudFormation This is a loaded topic, which we will discuss at length all through this repo. For now from a high level view here are some key benefits of choosing CDK. Imperative vs. Declarative As IaC becomes more popular many topics surrounding have been highly debated. One of those that we will discuss at length is Imperative programming vs. Declarative programming. Both Imperative and Declarative programming are paradigms that can be followed when we are writing code. To think about how these paradigms differ we can consider the following: - Declarative Programming: - Is an expression of logic that does not describe a control flow. - Often more easily understood - \"Is what we want\" - Imperative Programming: - Uses statements to change a program's state. - Finer grain control over execution - \"Is how to get what we want\" CDK is often referred to as an Imperative tool, and at first glance that is the easiest way to view it. Though really CDK is a declarative tool that is broadened by the use of imperative programming languages that we used to create our CDK definitions. The idea of using an imperative language to create declarative templates may be a little strange at first, however we will soon see the simplicity behind the concept and what benefits we gain by using it. Language Choices CDK currently supports: Fully Supported: TypeScript Supported With Experimental Features: Python Java C# Developer Preview Available: GO Important Note: Only Typescript is fully supported with all CDK features. As well it is the ONLY language that has a testing framework we can use to test our code before deploying it. Overview of Benefits One of the most exciting benefits about CDK is the speed and agility it gives us to create complex AWS Resources. Lets take this example from AWS export class MyEcsConstructStack extends core . Stack { constructor ( scope : core.App , id : string , props? : core.StackProps ) { super ( scope , id , props ); const vpc = new ec2 . Vpc ( this , \"MyVpc\" , { maxAzs : 3 // Default is all AZs in region }); const cluster = new ecs . Cluster ( this , \"MyCluster\" , { vpc : vpc }); // Create a load-balanced Fargate service and make it public new ecs_patterns . ApplicationLoadBalancedFargateService ( this , \"MyFargateService\" , { cluster : cluster , // Required cpu : 512 , // Default is 256 desiredCount : 6 , // Default is 1 taskImageOptions : { image : ecs.ContainerImage.fromRegistry ( \"amazon/amazon-ecs-sample\" ) }, memoryLimitMiB : 2048 , // Default is 512 publicLoadBalancer : true // Default is false }); } } The above code snippet produces a CloudFormation template of over 500 lines and 50 resources. CloudFormation Template HERE You may also note we did not have to create any IAM roles or policies, that is because CDK will use least privilege principles to generate Roles and Policies for us. Though if we desired defining or adding to the policies we can easily with CDK. Some other advantages consist of: Use of logic when defining infrastructure (if statements, loops, etc) Object-oriented techniques that our chosen language provides the tool set for Define high level abstractions, that can be shared across the organization Creating a reusable and sharable infrastructure library Testing infrastructure before we ever deploy IDE Intelli-sense support","title":"What is AWS CDK?"},{"location":"infrastructure-as-code/what-is-cdk/#what-is-aws-cdk","text":"AWS Cloud Development Kit (CDK) is an opensource software development framework used to define our Infrastructure as Code (IaC). Using CDK allows us to use familiar programming languages to provision our AWS Resources. At its core CDK makes use of AWS CloudFormation in order to deploy our AWS resources. This makes having some level of CloudFormation understanding very useful as you continue to create your CDK application templates. Important Important Note: Keep in mind, though CDK uses CloudFormation we are NOT writing CloudFormation templates in Typescript or Python. We are writing CDK code that happens to use CloudFormation for deployment.","title":"What is AWS CDK?"},{"location":"infrastructure-as-code/what-is-cdk/#cdk-vs-pure-cloudformation","text":"This is a loaded topic, which we will discuss at length all through this repo. For now from a high level view here are some key benefits of choosing CDK.","title":"CDK vs. Pure CloudFormation"},{"location":"infrastructure-as-code/what-is-cdk/#imperative-vs-declarative","text":"As IaC becomes more popular many topics surrounding have been highly debated. One of those that we will discuss at length is Imperative programming vs. Declarative programming. Both Imperative and Declarative programming are paradigms that can be followed when we are writing code. To think about how these paradigms differ we can consider the following: - Declarative Programming: - Is an expression of logic that does not describe a control flow. - Often more easily understood - \"Is what we want\" - Imperative Programming: - Uses statements to change a program's state. - Finer grain control over execution - \"Is how to get what we want\" CDK is often referred to as an Imperative tool, and at first glance that is the easiest way to view it. Though really CDK is a declarative tool that is broadened by the use of imperative programming languages that we used to create our CDK definitions. The idea of using an imperative language to create declarative templates may be a little strange at first, however we will soon see the simplicity behind the concept and what benefits we gain by using it.","title":"Imperative vs. Declarative"},{"location":"infrastructure-as-code/what-is-cdk/#language-choices","text":"CDK currently supports: Fully Supported: TypeScript Supported With Experimental Features: Python Java C# Developer Preview Available: GO Important Note: Only Typescript is fully supported with all CDK features. As well it is the ONLY language that has a testing framework we can use to test our code before deploying it.","title":"Language Choices"},{"location":"infrastructure-as-code/what-is-cdk/#overview-of-benefits","text":"One of the most exciting benefits about CDK is the speed and agility it gives us to create complex AWS Resources. Lets take this example from AWS export class MyEcsConstructStack extends core . Stack { constructor ( scope : core.App , id : string , props? : core.StackProps ) { super ( scope , id , props ); const vpc = new ec2 . Vpc ( this , \"MyVpc\" , { maxAzs : 3 // Default is all AZs in region }); const cluster = new ecs . Cluster ( this , \"MyCluster\" , { vpc : vpc }); // Create a load-balanced Fargate service and make it public new ecs_patterns . ApplicationLoadBalancedFargateService ( this , \"MyFargateService\" , { cluster : cluster , // Required cpu : 512 , // Default is 256 desiredCount : 6 , // Default is 1 taskImageOptions : { image : ecs.ContainerImage.fromRegistry ( \"amazon/amazon-ecs-sample\" ) }, memoryLimitMiB : 2048 , // Default is 512 publicLoadBalancer : true // Default is false }); } } The above code snippet produces a CloudFormation template of over 500 lines and 50 resources. CloudFormation Template HERE You may also note we did not have to create any IAM roles or policies, that is because CDK will use least privilege principles to generate Roles and Policies for us. Though if we desired defining or adding to the policies we can easily with CDK. Some other advantages consist of: Use of logic when defining infrastructure (if statements, loops, etc) Object-oriented techniques that our chosen language provides the tool set for Define high level abstractions, that can be shared across the organization Creating a reusable and sharable infrastructure library Testing infrastructure before we ever deploy IDE Intelli-sense support","title":"Overview of Benefits"}]}